# Default values for ditto-umbrella-chart.
# This is a YAML-formatted file.
# Declare variables to be passed into your templates.

global:
  debug: false
  trace: false

  # Create a storage class for local k8s clusters or k8s clusters that do not use dynamic provisioners out of box
  # Default provisioner is for rancher cluster
  # Disable if you have a k8s cluster with a default dynamic provisioner
  storageClass:
    create: false

  privateCA: false

  # comma separated list of domains or ip addresses that will not use the proxy
  noProxy: 127.0.0.0/8,10.0.0.0/8,172.16.0.0/12,192.168.0.0/16,.svc,.cluster.local

  imagePullSecrets: []

  serviceAccount:
    # Specifies whether a service account should be created
    create: true
    # Annotations to add to the service account
    annotations: {}
    # The name of the service account to use.
    # If not set and create is true, a name is generated using the fullname template
    name: ""

  podAnnotations: {}

  podSecurityContext:
    {}
    # fsGroup: 2000

  securityContext:
    {}
    # capabilities:
    #   drop:
    #   - ALL
    # readOnlyRootFilesystem: true
    # runAsNonRoot: true
    # runAsUser: 1000

  nodeSelector: {}
  tolerations: []
  affinity: {}

ditto-deployment:
  name: bp
  version: 1.40.3
  image:
    namePrefix: quay.io/ditto-external
    pullPolicy: IfNotPresent
    pullSecrets: []
  pki:
    device:
      secretName: '{{ .Release.Name }}-subserver-cert-pki'
    inband:
      secretName: '{{ .Release.Name }}-subserver-jwt-pki'
    jwt:
      secretName: '{{ .Release.Name }}-subserver-jwt-pki'
  storage:
    storage_class_name: local-path
  transactions:
    kafka:
      topic:
        name: transaction.log
        partitions: 1
        replicas: 1
      bootstrapHost: ditto-bp-kafka-kafka-bootstrap.big-peer.svc.cluster.local:9092
  providers:
    dummyProvider:
      tokenWebhook:
        url: "http://ditto-bp-dummy-auth-webhook/validate_token"
    internal:
      tokenWebhook:
        url: "http://ditto-bp-service-token-validator/v1.0/token-validation/ditto"

ditto-operator:
  namespace: ""
  operator:
    config:
      watchNamespace: null
      bindAddress: 0.0.0.0
      bindPort: 8080

    rbac:
      # -- If the global ClusterRole and ClusterRoleBinding should be created.
      create: true

    serviceAccount:
      # -- Specifies whether a ServiceAccount should be created. This can be unset and name specified
      # if you want to use an existing ServiceAccount.
      create: true

      # -- The name of the ServiceAccount to use. If unset and create is true, fullname is used.
      name: ""

      # -- Automount API credentials for the Service Account using automountServiceAccountToken.
      automount: true

      # -- optional additional annotations to add to the controller's service account.
      extraAnnotations: {}

      # -- optional additional labels to add to the controller's service account.
      extraLabels: {}

    image:
      # -- The container registry to pull the acmesolver image from.
      registry: quay.io

      # -- The container image for the operator controller.
      repository: ditto-external/ditto-operator

      # -- Override the image tag to deploy by setting this variable. If no value is set, the chart's
      # appVersion is used.
      tag: "v0.1.1"
        # tag: vX.Y.Z

      # -- Setting a digest will override any tag.
      digest: ""
        # digest: sha256:0e072dddd1f7f8fc8909a2ca6f65e76c5f0d2fcfb8be47935ae3457e8bbceb20

      # -- Kubernetes imagePullPolicy on Deployment.
      pullPolicy: IfNotPresent

      # -- Reference to one or more secrets to be used when pulling images.
      #
      # For more information, see [Pull an Image from a Private Registry](https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/).
      pullSecrets: []
        # - name: "image-pull-secret"

    # -- Number of replicas to run in the Deployment.
    #
    # Note: for preview, only 1 replica is supported until leader election is feature complete.
    replicaCount: 1

    # -- Number of old ReplicaSets to retain for the Deployment before garbage collection occurs.
    revisionHistoryLimit: 10

    # -- Auth config
    auth:
      providers:
        dummyProvider:
          tokenWebhook:
            url: http://dummy-auth-webhook/validate_token

    # -- Specify externally managed Kafka settings, telling Ditto Operator where to find Big Peer's Kafka cluster
    transactions:
      kafka:
        external:
          enabled: true
          topicName: transaction.log
          bootstrapServers:
          - host: ditto-bp-kafka-kafka-bootstrap.big-peer.svc.cluster.local
            port: 9092

    # -- Specify small peer PKI / signers
    # The default here is to use cert-manager to handle certificates
    keys:
      certManager:
        template:
          issuer:
            metadata:
              annotations: {}
              labels: {}
          caCertificate:
            metadata:
              annotations: {}
              labels: {}
            issuerRef:
              group: cert-manager.io
              kind: ClusterIssuer
              name: example-cluster-issuer
            secretTemplate:
              metadata:
                annotations: {}
                labels: {}
          inBandCertificate:
            metadata:
              annotations: {}
              labels: {}
            issuerRef:
              group: cert-manager.io
              kind: ClusterIssuer
              name: example-cluster-issuer
            secretTemplate:
              metadata:
                annotations: {}
                labels: {}
          jwtCertificate:
            metadata:
              annotations: {}
              labels: {}
            issuerRef:
              group: cert-manager.io
              kind: ClusterIssuer
              name: example-cluster-issuer
            secretTemplate:
              metadata:
                annotations: {}
                labels: {}

    # -- Resources to provide to the operator controller pod.
    #
    # For more information, see [Resource Management for Pods and Containers](https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/).
    resources: {}
      #  requests:
      #    cpu: 100m
      #    memory: 1Gi

    # Deployment update strategy for the operator controller deployment.
    # For more information, see the [Kubernetes documentation](https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#strategy).
    strategy: {}
      #  strategy:
      #    type: RollingUpdate
      #    rollingUpdate:
      #      maxSurge: 0
      #      maxUnavailable: 1

    # -- The optional priority class to be used for the operator pods.
    priorityClassName: ""

    # -- The nodeSelector on Pods tells Kubernetes to schedule Pods on the nodes with matching labels.
    #
    # For more information, see [Assigning Pods to Nodes](https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/).
    #
    #
    # This default ensures that Pods are only scheduled to Linux nodes. It prevents Pods being scheduled to Windows nodes in a mixed OS cluster.
    nodeSelector:
      kubernetes.io/os: linux

    # A Kubernetes Affinity, if required. For more information, see [Affinity v1 core](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.27/#affinity-v1-core).
    #
    # For example:
    #   affinity:
    #     nodeAffinity:
    #      requiredDuringSchedulingIgnoredDuringExecution:
    #        nodeSelectorTerms:
    #        - matchExpressions:
    #          - key: foo.bar.com/role
    #            operator: In
    #            values:
    #            - master
    affinity: {}

    # A list of Kubernetes Tolerations, if required. For more information, see [Toleration v1 core](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.27/#toleration-v1-core).
    #
    # For example:
    #   tolerations:
    #   - key: foo.bar.com/role
    #     operator: Equal
    #     value: master
    #     effect: NoSchedule
    tolerations: []

    # A list of Kubernetes TopologySpreadConstraints, if required. For more information, see [Topology spread constraint v1 core](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.27/#topologyspreadconstraint-v1-core
    #
    # For example:
    #   topologySpreadConstraints:
    #   - maxSkew: 2
    #     topologyKey: topology.kubernetes.io/zone
    #     whenUnsatisfiable: ScheduleAnyway
    #     labelSelector:
    #       matchLabels:
    #         app.kubernetes.io/instance: operator
    #         app.kubernetes.io/component: controller
    topologySpreadConstraints: []

    # Pod Security Context.
    # For more information, see [Configure a Security Context for a Pod or Container](https://kubernetes.io/docs/tasks/configure-pod-container/security-context/).
    # +docs:property
    securityContext:
      runAsNonRoot: true
      seccompProfile:
        type: RuntimeDefault

    # Container Security Context to be set on the controller component container.
    # For more information, see [Configure a Security Context for a Pod or Container](https://kubernetes.io/docs/tasks/configure-pod-container/security-context/).
    # +docs:property
    containerSecurityContext:
      allowPrivilegeEscalation: false
      readOnlyRootFilesystem: true
      capabilities:
        drop:
        - ALL

    # LivenessProbe settings for the controller container of the controller Pod.
    #
    # This is enabled by default, in order to enable the clock-skew liveness probe that
    # restarts the controller in case of a skew between the system clock and the monotonic clock.
    # LivenessProbe durations and thresholds are based on those used for the Kubernetes
    # controller-manager. For more information see the following on the
    # [Kubernetes GitHub repository](https://github.com/kubernetes/kubernetes/blob/806b30170c61a38fedd54cc9ede4cd6275a1ad3b/cmd/kubeadm/app/util/staticpod/utils.go#L241-L245)
    # +docs:property
    livenessProbe:
      enabled: true
      path: /healthz
      initialDelaySeconds: 10
      periodSeconds: 10
      timeoutSeconds: 15
      successThreshold: 1
      failureThreshold: 8

    # -- Optional additional annotations to add to the controller's service account.
    extraAnnotations: {}

    # -- Optional additional labels to add to the controller's service account.
    extraLabels: {}

    # Additional volumes to add to the operator controller pod.
    extraVolumes: []

    # Additional volume mounts to add to the operator controller container.
    extraVolumeMounts: []

    # Additional command line flags to pass to operator controller binary.
    # To see all available flags run docker run quay.io/jetstack/operator-controller:<version> --help.
    #
    # Use this flag to enable or disable arbitrary controllers. For example, to disable the CertificateRequests approver.
    #
    # For example:
    #  extraArgs:
    #    - --controllers=*,-certificaterequests-approver
    extraArgs: []

    # Additional environment variables to pass to operator controller binary.
    # For example:
    #  extraEnv:
    #  - name: SOME_VAR
    #    value: 'some value'
    extraEnv: []

    # -- Additional init containers to run as part of the operator deployment
    extraInitContainers: []
      # - name: hello-once
      # args:
      #   - -c
      #   - "echo 'Hello World!'"
      # command:
      #   - /bin/sh
      # image: 'busybox:glibc'

    # -- Additional containers to run as part of the operator deployment
    extraContainers: []
      # - name: hello-many
      # args:
      #   - -c
      #   - "while true; do echo hi; sleep 300; done"
      # command:
      #   - /bin/sh
      # image: 'busybox:glibc'

  # Create dynamic manifests via values.
  #
  # For example:
  # extraObjects:
  #   - |
  #     apiVersion: v1
  #     kind: ConfigMap
  #     metadata:
  #       name: '{{ template "operator.fullname" . }}-extra-configmap'
  extraObjects: []

apps:
  myApp:
    enabled: false
    id: 891c1bdb-71c6-40d5-9374-128e467c367e  # uuid generated via uuidgen

    liveQuery:
      enabled: false
      queries:
        - name: "all_the_things"
          enabled: true
          queryFilterExpression: "true"
          schema: untyped
          sinks:
            kafka:
              enabled: true
            webhook:
              enabled: true
              url: "http://myapp.com/rimshot"
        - name: "send_to_hook"
          enabled: true
          queryFilterExpression: "true"
          schema: untyped
          sinks:
            webhook:
              enabled: true
              url: "http://myapp.com/rimshot"

# global kafka cluster options
kafka:
  networkPolicies:
    enabled: false
  # enable kraft mode for dual use Kafka nodes in a common node pool
  kraft:
    enabled: false
    nodePool:
      dualRoles: true
      replicas: 1

  # disable kafka supporting services that are not required
  strimzi:
    # interBrokerProtocolVersion: 3.8.0
    kafkaVersion: 3.8.0
    kafkaExporter:
      enabled: false
    cruiseControl:
      enabled: false

######################################
# Service Token Validator
#####################################
# Default values for service-token-validator.
# This is a YAML-formatted file.
# Declare variables to be passed into your templates.
service-token-validator:
  enabled: false

######################################
# Cert Manager
# More Information see https://github.com/cert-manager/cert-manager/blob/master/deploy/charts/cert-manager/values.yaml
######################################

# Default values for cert-manager.
# This is a YAML-formatted file.
# Declare variables to be passed into your templates.
cert-manager:
  enabled: true

  replicaCount: 2
  namespace: kube-system

  strategy:
    {}
    # type: RollingUpdate
    # rollingUpdate:
    #   maxSurge: 0
    #   maxUnavailable: 1

  # Comma separated list of feature gates that should be enabled on the
  # controller pod.
  featureGates: ""

  serviceAccount:
    # Specifies whether a service account should be created
    create: true
    # The name of the service account to use.
    # If not set and create is true, a name is generated using the fullname template
    # name: ""
    # Optional additional annotations to add to the controller's ServiceAccount
    # annotations: {}
    # Automount API credentials for a Service Account.
    automountServiceAccountToken: true

  # Optional additional arguments
  extraArgs:
    # Use this flag to set a namespace that cert-manager will use to store
    # supporting resources required for each ClusterIssuer (default is kube-system)
    # - --cluster-resource-namespace=kube-system
    # When this flag is enabled, secrets will be automatically removed when the certificate resource is deleted
    - --enable-certificate-owner-ref=true
    # Use this flag to enabled or disable arbitrary controllers, for example, disable the CertificiateRequests approver
    # - --controllers=*,-certificaterequests-approver

  extraEnv: []
  # - name: SOME_VAR
  #   value: 'some value'

  resources:
    requests:
      cpu: 10m
      memory: 32Mi

  # Pod Security Context
  # ref: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
  securityContext:
    runAsNonRoot: true
  # legacy securityContext parameter format: if enabled is set to true, only fsGroup and runAsUser are supported
  # securityContext:
  #   enabled: false
  #   fsGroup: 1001
  #   runAsUser: 1001
  # to support additional securityContext parameters, omit the `enabled` parameter and simply specify the parameters
  # you want to set, e.g.
  # securityContext:
  #   fsGroup: 1000
  #   runAsUser: 1000
  #   runAsNonRoot: true

  # Container Security Context to be set on the controller component container
  # ref: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
  containerSecurityContext:
    {}
    # capabilities:
    #   drop:
    #   - ALL
    # readOnlyRootFilesystem: true
    # runAsNonRoot: true

  volumes: []

  volumeMounts: []

  # Optional additional annotations to add to the controller Deployment
  # deploymentAnnotations: {}

  # Optional additional annotations to add to the controller Pods
  # podAnnotations: {}

  podLabels:
    app.ditto.live/tier: "master"
    app.ditto.live/exposed: "false"
    app.ditto.live/runtime: "golang"
    app.ditto.live/repo: "cloud-infra"

  # Optional additional labels to add to the controller Service
  # serviceLabels: {}

  # Optional DNS settings, useful if you have a public and private DNS zone for
  # the same domain on Route 53. What follows is an example of ensuring
  # cert-manager can access an ingress or DNS TXT records at all times.
  # NOTE: This requires Kubernetes 1.10 or `CustomPodDNS` feature gate enabled for
  # the cluster to work.
  # podDnsPolicy: "None"
  # podDnsConfig:
  #   nameservers:
  #     - "1.1.1.1"
  #     - "8.8.8.8"

  # Ensure the pods are deployed to nodes with the matching laebls
  # nodeSelector:
  #   app.ditto.live/tier: "infrastructure"

  ingressShim:
    {}
    # defaultIssuerName: ""
    # defaultIssuerKind: ""
    # defaultIssuerGroup: ""

  prometheus:
    enabled: false

######################################
# Dummy Auth Webhook
#####################################
dummy-auth-webhook:
  enabled: true

  image:
    name: quay.io/ditto-external/big-peer-auth-webhook:1.39.2
    pullPolicy: IfNotPresent


######################################
# Live Query
#####################################
live-query:
  enabled: true

  image:
    repository: quay.io/ditto-external/big-peer-live-query-resource-controller
    tag: latest

  env:
    # Main config
    INSTANCE_NAME: "live-query-resource-controller"
    LIVE_QUERY_WATCHER_NAMESPACE: "bp"
    TARGET_NAMESPACE_TEMPLATE: "bp"
    APP_LABEL_SELECTOR: "app.kubernetes.io/instance=ditto-bp"
    DEPLOY_NETWORK_POLICIES: false
    DEPLOY_SERVICE_MONITORS: false

    # Kafka user ingress config
    KAFKA_INGRESS_DOMAIN: ""
    KAFKA_INGRESS_CLASS: ""
    KAFKA_REPLICATION_FACTOR: "1"

    # CDC workload config
    CDC_RESOURCE_REQUEST_CPU: 40m
    CDC_RESOURCE_REQUEST_MEMORY: 1G
    CDC_RESOURCE_LIMIT_MEMORY: 4G
    CDC_IMAGE: quay.io/ditto-external/hydra-cdc:1.39.2
    CDC_TOKEN_AUDIENCE: cloud.ditto.live
    CDC_KAFKA_REPLICATION_FACTOR: 1

    # StreamSplitter workload config
    STREAM_SPLITTER_RESOURCE_REQUEST_CPU: 20m
    STREAM_SPLITTER_RESOURCE_REQUEST_MEMORY: 256Mi
    STREAM_SPLITTER_RESOURCE_LIMIT_MEMORY: 1G
    STREAM_SPLITTER_IMAGE: quay.io/ditto-external/hydra-stream-splitter:1.39.2
    STREAM_SPLITTER_TOKEN_AUDIENCE: cloud.ditto.live

    # WebhookDispatcher workload config
    WEBHOOK_DISPATCHER_RESOURCE_REQUEST_CPU: 20m
    WEBHOOK_DISPATCHER_RESOURCE_REQUEST_MEMORY: 24Mi
    WEBHOOK_DISPATCHER_RESOURCE_LIMIT_MEMORY: 128Mi
    WEBHOOK_DISPATCHER_IMAGE: quay.io/ditto-external/hydra-webhook-dispatcher:1.39.2
    WEBHOOK_DISPATCHER_TOKEN_AUDIENCE: cloud.ditto.live

    # CDC Hearbeat workload config
    CDC_HEARTBEAT_RESOURCE_REQUEST_CPU: 20m
    CDC_HEARTBEAT_RESOURCE_REQUEST_MEMORY: 50Mi
    CDC_HEARTBEAT_RESOURCE_LIMIT_MEMORY: 150Mi
    CDC_HEARTBEAT_IMAGE: quay.io/ditto-external/cdc-heartbeat:1.39.2
    CDC_HEARTBEAT_TOKEN_AUDIENCE: cloud.ditto.live
    CDC_HEARTBEAT_KAFKA_REPLICATION_FACTOR: 1

live-query-kafka:
  networkPolicies:
    enabled: false
  # enable kraft mode for dual use Kafka nodes in a common node pool
  kraft:
    enabled: false
    nodePool:
      dualRoles: true
      replicas: 1

  # disable kafka supporting services that are not required
  strimzi:
    replicas: 3
    authorization: simple
    external: true

    # interBrokerProtocolVersion: 3.8.0
    kafkaVersion: 3.8.0
    kafkaExporter:
      enabled: false
    cruiseControl:
      enabled: false
