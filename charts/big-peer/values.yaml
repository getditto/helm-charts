# Default values for ditto-umbrella-chart.
# This is a YAML-formatted file.
# Declare variables to be passed into your templates.

global:
  debug: false
  trace: false

  # Create a storage class for local k8s clusters or k8s clusters that do not use dynamic provisioners out of box
  # Default provisioner is for rancher cluster
  # Disable if you have a k8s cluster with a default dynamic provisioner
  storageClass:
    create: false

  privateCA: false

  # comma separated list of domains or ip addresses that will not use the proxy
  noProxy: 127.0.0.0/8,10.0.0.0/8,172.16.0.0/12,192.168.0.0/16,.svc,.cluster.local

  imagePullSecrets: []

  serviceAccount:
    # Specifies whether a service account should be created
    create: true
    # Annotations to add to the service account
    annotations: {}
    # The name of the service account to use.
    # If not set and create is true, a name is generated using the fullname template
    name: ""

  podAnnotations: {}

  podSecurityContext:
    {}
    # fsGroup: 2000

  securityContext:
    {}
    # capabilities:
    #   drop:
    #   - ALL
    # readOnlyRootFilesystem: true
    # runAsNonRoot: true
    # runAsUser: 1000

  nodeSelector: {}
  tolerations: []
  affinity: {}

controller:
  # -- Number of desired pods
  replicas: 1

image:
  # -- image repository
  repository: quay.io/ditto-external/ditto-operator
  # -- image tag
  tag: 0.1.0-preview

  pullPolicy: IfNotPresent

# -- Configures service settings for the chart.
# @default -- See values.yaml
service:
  main:
    enabled: false

ingress:
  # -- Enable and configure ingress settings for the chart under this key.
  # @default -- See values.yaml
  main:
    enabled: false

apps:
  myApp:
    enabled: false
    id: 891c1bdb-71c6-40d5-9374-128e467c367e  # uuid generated via uuidgen

    liveQuery:
      enabled: false
      queries:
        - name: "all_the_things"
          enabled: true
          queryFilterExpression: "true"
          schema: untyped
          sinks:
            kafka:
              enabled: true
            webhook:
              enabled: true
              url: "http://myapp.com/rimshot"
        - name: "send_to_hook"
          enabled: true
          queryFilterExpression: "true"
          schema: untyped
          sinks:
            webhook:
              enabled: true
              url: "http://myapp.com/rimshot"

# global kafka cluster options
kafka:
  networkPolicies:
    enabled: false
  # enable kraft mode for dual use Kafka nodes in a common node pool
  kraft:
    enabled: false
    nodePool:
      dualRoles: true
      replicas: 1

  # disable kafka supporting services that are not required
  strimzi:
    # interBrokerProtocolVersion: 3.8.0
    kafkaVersion: 3.8.0
    kafkaExporter:
      enabled: false
    cruiseControl:
      enabled: false

  certManager:
    enabled: true
    selfSignedIssuer:
      create: true
      name: selfsigned-issuer

  networkPolicies:
    enabled: false

######################################
# Cert Manager
# More Information see https://github.com/cert-manager/cert-manager/blob/master/deploy/charts/cert-manager/values.yaml
######################################

# Default values for cert-manager.
# This is a YAML-formatted file.
# Declare variables to be passed into your templates.
cert-manager:
  enabled: true

  replicaCount: 2
  namespace: kube-system

  strategy:
    {}
    # type: RollingUpdate
    # rollingUpdate:
    #   maxSurge: 0
    #   maxUnavailable: 1

  # Comma separated list of feature gates that should be enabled on the
  # controller pod.
  featureGates: ""

  serviceAccount:
    # Specifies whether a service account should be created
    create: true
    # The name of the service account to use.
    # If not set and create is true, a name is generated using the fullname template
    # name: ""
    # Optional additional annotations to add to the controller's ServiceAccount
    # annotations: {}
    # Automount API credentials for a Service Account.
    automountServiceAccountToken: true

  # Optional additional arguments
  extraArgs:
    # Use this flag to set a namespace that cert-manager will use to store
    # supporting resources required for each ClusterIssuer (default is kube-system)
    # - --cluster-resource-namespace=kube-system
    # When this flag is enabled, secrets will be automatically removed when the certificate resource is deleted
    - --enable-certificate-owner-ref=true
    # Use this flag to enabled or disable arbitrary controllers, for example, disable the CertificiateRequests approver
    # - --controllers=*,-certificaterequests-approver

  extraEnv: []
  # - name: SOME_VAR
  #   value: 'some value'

  resources:
    requests:
      cpu: 10m
      memory: 32Mi

  # Pod Security Context
  # ref: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
  securityContext:
    runAsNonRoot: true
  # legacy securityContext parameter format: if enabled is set to true, only fsGroup and runAsUser are supported
  # securityContext:
  #   enabled: false
  #   fsGroup: 1001
  #   runAsUser: 1001
  # to support additional securityContext parameters, omit the `enabled` parameter and simply specify the parameters
  # you want to set, e.g.
  # securityContext:
  #   fsGroup: 1000
  #   runAsUser: 1000
  #   runAsNonRoot: true

  # Container Security Context to be set on the controller component container
  # ref: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
  containerSecurityContext:
    {}
    # capabilities:
    #   drop:
    #   - ALL
    # readOnlyRootFilesystem: true
    # runAsNonRoot: true

  volumes: []

  volumeMounts: []

  # Optional additional annotations to add to the controller Deployment
  # deploymentAnnotations: {}

  # Optional additional annotations to add to the controller Pods
  # podAnnotations: {}

  podLabels:
    app.ditto.live/tier: "master"
    app.ditto.live/exposed: "false"
    app.ditto.live/runtime: "golang"
    app.ditto.live/repo: "cloud-infra"

  # Optional additional labels to add to the controller Service
  # serviceLabels: {}

  # Optional DNS settings, useful if you have a public and private DNS zone for
  # the same domain on Route 53. What follows is an example of ensuring
  # cert-manager can access an ingress or DNS TXT records at all times.
  # NOTE: This requires Kubernetes 1.10 or `CustomPodDNS` feature gate enabled for
  # the cluster to work.
  # podDnsPolicy: "None"
  # podDnsConfig:
  #   nameservers:
  #     - "1.1.1.1"
  #     - "8.8.8.8"

  # Ensure the pods are deployed to nodes with the matching laebls
  # nodeSelector:
  #   app.ditto.live/tier: "infrastructure"

  ingressShim:
    {}
    # defaultIssuerName: ""
    # defaultIssuerKind: ""
    # defaultIssuerGroup: ""

  prometheus:
    enabled: false

######################################
# Live Query
#####################################
live-query:
  enabled: false

  image:
    repository: quay.io/ditto-external/big-peer-live-query-resource-controller
    tag: latest

  env:
    # Main config
    INSTANCE_NAME: "live-query-resource-controller"
    LIVE_QUERY_WATCHER_NAMESPACE: "bp"
    TARGET_NAMESPACE_TEMPLATE: "bp"
    APP_LABEL_SELECTOR: "app.kubernetes.io/instance=ditto-bp"
    DEPLOY_NETWORK_POLICIES: false
    DEPLOY_SERVICE_MONITORS: false

    # Kafka user ingress config
    KAFKA_INGRESS_DOMAIN: ""
    KAFKA_INGRESS_CLASS: ""
    KAFKA_REPLICATION_FACTOR: "1"

    # CDC workload config
    CDC_RESOURCE_REQUEST_CPU: 40m
    CDC_RESOURCE_REQUEST_MEMORY: 1G
    CDC_RESOURCE_LIMIT_MEMORY: 4G
    CDC_IMAGE: quay.io/ditto-external/hydra-cdc:1.39.2
    CDC_TOKEN_AUDIENCE: cloud.ditto.live
    CDC_KAFKA_REPLICATION_FACTOR: 1

    # StreamSplitter workload config
    STREAM_SPLITTER_RESOURCE_REQUEST_CPU: 20m
    STREAM_SPLITTER_RESOURCE_REQUEST_MEMORY: 256Mi
    STREAM_SPLITTER_RESOURCE_LIMIT_MEMORY: 1G
    STREAM_SPLITTER_IMAGE: quay.io/ditto-external/hydra-stream-splitter:1.39.2
    STREAM_SPLITTER_TOKEN_AUDIENCE: cloud.ditto.live

    # WebhookDispatcher workload config
    WEBHOOK_DISPATCHER_RESOURCE_REQUEST_CPU: 20m
    WEBHOOK_DISPATCHER_RESOURCE_REQUEST_MEMORY: 24Mi
    WEBHOOK_DISPATCHER_RESOURCE_LIMIT_MEMORY: 128Mi
    WEBHOOK_DISPATCHER_IMAGE: quay.io/ditto-external/hydra-webhook-dispatcher:1.39.2
    WEBHOOK_DISPATCHER_TOKEN_AUDIENCE: cloud.ditto.live

    # CDC Hearbeat workload config
    CDC_HEARTBEAT_RESOURCE_REQUEST_CPU: 20m
    CDC_HEARTBEAT_RESOURCE_REQUEST_MEMORY: 50Mi
    CDC_HEARTBEAT_RESOURCE_LIMIT_MEMORY: 150Mi
    CDC_HEARTBEAT_IMAGE: quay.io/ditto-external/cdc-heartbeat:1.39.2
    CDC_HEARTBEAT_TOKEN_AUDIENCE: cloud.ditto.live
    CDC_HEARTBEAT_KAFKA_REPLICATION_FACTOR: 1

live-query-kafka:
  networkPolicies:
    enabled: false
  # enable kraft mode for dual use Kafka nodes in a common node pool
  kraft:
    enabled: false
    nodePool:
      dualRoles: true
      replicas: 1

  # disable kafka supporting services that are not required
  strimzi:
    replicas: 3
    authorization: simple
    external: true

    # interBrokerProtocolVersion: 3.8.0
    kafkaVersion: 3.8.0
    kafkaExporter:
      enabled: false
    cruiseControl:
      enabled: false
